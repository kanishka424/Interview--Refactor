time 0.0 image
we have a we have a load balancer  and this load balancer would redirect mobile phone request to these servers(s1,s2,s3)


when you see a single thing like db or load balncer here it is a single point of failure

if fails businees stops 

so to get over single pint  of failure we use replication
we keep another db which is a replication 
its good to have it in another db because if hw crash both crash
question rAID CARD????


NOW YOU HAVE THIS REPLICATION HOW YOU ARE GOING TO PULL FROM THIS DB?
TWO WAYS 
1)AYNC
2)SYNC


1)ASYNC

GOODTHING NOT TOO MUCH LOAD ON DB
TEHRE IS NO OMEBDY CONTINOUESLY ASKING FOR AN UPDATE EVERY TIME UPDATE HAPPENS
DISADVATGE IS OUT OF SYNC
INCONSISTENT DATA
APPLICATION MUSST BE WILLING TO HANDLE SOME ASYNCHRONUS DATA


2)SYNC

as soon as prime db gets an update it will send message to copy saying hey I got an update you can add this commnad ti your transaction log


e.g add 100 to userId 1 is a command master  got
mater gets the command and end it to slave so command can be run there and replica will have the same consistent stae as master all coomands are in same seerail order we make thi assumption here??(time 3.59 image)
 
time 3.12 waht if s3 server wants to update slave db
im going to add rs.200 to user id 2


if this is the case the salve needs to tell master and that change needs to propagaated to upwards(to master) (time 3.20)
there are two ways to thi proble 

1)one way is to ignore the problem
or never to let problem happen to do that WE HAVE TO AVOID WRITING TO SLAVES


2) second way is to allow this and let slave propgate to master9adding rs.200 to user Id 2)
IN THIS CASE THIS IS NO LONGER MASTER SLVAE BUT ;PEER TO PEER\
BECAUSE BOTH OF THEM ARE MASTER 
KEY POINT HERE IS ANY DB THAT CAN TAKE WRITES ARE MATER DB SO WE HAVE A MASTER MATER REALTION HERE
THERE WOULD BE A BACK AND FORTH COMMUNICATION BETWEEN THE DBS(TIME 04.17 IMAGE)
HERE IF ONE DB FAILS OTHER WOYULD GAIN ITS PLACE SO YOU MIGHT THINK THERE IS HIGH REELIENCE
BUT THE PROBLEM WITH DITRIBUTD SYTEMS IS NETWORK CAN FAILS

WHAT HAPPENS IF THERE ARE TWO DBS "A" AND "B" AND THOUGH "B" HAS NOT FAILED ROUTR BETWEEN "A" AND "B" FAILED????
(TIME  05.27 BLUE COLURE SKETCH BELOW)



IN THI CASE  "A" ASSUMES IM THE MASTER I CAN DO READS AND WRITES HERE
TAHTS EXACTLY "B"ALSO WOULD SAY IT WOULD SAY IM THEE MASTER  I CAN DO READ AND WRITES

EG-TIME 05.56


IF TH USER SEND TO "A" I NEED TO REDUCE 100 AND TO "B" TAHT I NEED TO REDUCE 50
WHEN USER ONLY HAVE 120 IT WILL REMAIN AS NEGATIVE AMOUNT WHICH IS CALLED A "SPLIT BRAIN PROBLEM"

TIME 6.12
SPLIT BRAIN CAN BE SOLVED USING A THIRD NODE
BUT YOU HAVE TO BE BASED ON AN ASSUMPTION
TIME 06.29
CHANCES OF A NODE CRASHING AND CHANCE OF ROUTER BREKING BETWEEN OTHER TWO NODES IS HIGHLY UNLIKELY SO WE GOING TO ASUME IT NEVER HAPPENS


SO IF "C" CRASSHES "A" AND "B" GOING TO BE IN SYNC WORLD GOING TO BE IN CONSISTENT STATE FOR THEM VIA ROUTER BETWEEN SO "C" CAN COME UP AGAIN AND THEY CAN SYNC FROM A OR B 

WHEN LINK BETWEEN AND B BREAKS(SPLIT BRAIN PROBLEM)
WHEN A GETS DATA "X" IT WOULD BE REFLECTED IN "C" 
SAY INITALLY NODES ARE IN STATE S0 AND AFTR X COMES TO "A" IT UPDATE TO STATE "SX" AND IT WILL PASS THE SAME DATA TO C THEN C WILL ALSO BE "SX"
NOW "B" GET Y AND "B" GETS STAE "SY"
BUT WHEN  B TRIES TO PROPAGET ITS STATE TO "C" IT WONT BE ALOWED 
BECAUSE "C" ASK FOR "B" PREVIOS SATE "B" SAYS IT IS S0 (SO->SY)
AND "C" WONT ALLOW IT BECAUSE ITS STATE IS SX
SO C TELLS B TO UPDATE ITS STAE TO SX AND THEN UPDATE TO SY
SO B ROLLSBACK ITS STATE AND SYNC UP WITH C AND GET SX SATE AT B 
AT THIS STAGE USER IS FINE SY TRANSACTION DID NOT GO THROUGH AND 
WE CAN RUN SY AGIN AND NOW WE CAN SAY "C' TO GO TO STATE SY

BEFORE COMMIT OF A TRANSACTION WE CAN ROOLLACK IT


A CAN NEVER HAVE TRANSACTION WHICH DOESNT HAVE UPDATED  STATE FROM "b" ALSO

WE ASSUME EITER ONE NODE OR ROUTER FAILS TWO THINGS CANT HAPPEN AT SAME TIME



TIME 9.05 DISTRIBUTED CONSENSUS 
MULTIPLE NODES AGREES ON A SAME FINAL STATE THIS IS HOW WE GOT SY TO EARLIER SCEANTIOR

THERE ARE MANY PRORTOCOLS FOR DITRIBUTE CONSENDSUS I HAVE SIMPLIFIED HERE (TIME 9.30)

1)2PC(NOT RECOMMENDED)
2)3PC
3)MVCC(MULTI VERSIN CONCURRENT CONTROLLER)(USED BY POSTEGRES)(PREFERS)



GOD THING ABOUT MVCC IS 
MULTI VAERSION-MULTIPLE COPIES OF SAME
SO IF I SEND MULTILE UPDATES TO SAME DATA IT KEEPS MULTIPLE COPIES
DEPEND ON YOUR REQUIRMENT IT BEHAVES IN CERTAIN WAYS
SO IF YOU ARE OKAY WITH DIRTY READS YOU CAN KEEP OLDR VERIN OF DATA AND SOME ONE CAN READ IT
BUT IF YOU SAY I NEED ALL SERILIZABLE READ AND NO PHANTOM READS IT I ALL ABOUT THAT
IT WILL BE SLOWER BUT ITS GOING T KEEP THAT DATA CONSISTENT WITH EVERYTHING ELSE


***HAVE A LOOK AT MVCC


***INTERESTING  PROTOCOL USED FOR GAME "HALO" IS SAGA USED BY MICROSOFT"

SAGA IS LIKE A LONG TRANSACTION

EAXAMPLE FRO SAGA (TIME10.51)(LITEN FEOM HERE NO NOTES PROPER)


LOCK FUNDS WHEN MAKING AN ORDER
ANY POINT THIS CAN FAIL 


TIME 12.16
WHY GO FOR MATRER LAVE 
1)NICE BACKUP
2)SCALE UP YOUR READS (WHEN DOING ANYLITIC YOU DONT NEED TO BE REAL TIME)
3)CAN ADD MANY SLAVES(CAN MAKE READ OPERATIONS ON SLAVE CAN MITIGATE USING SGHARDING)

IF C FIALS WE HAVE A CORDINATO R WHICH TELLS "C" SLAVE TO STEP UP AND TAKE ITS PLACE9BE NMATER)


UING 2PC YOU CANMAKE SURE "C" AND ITS SLVAE ARE IN SYNC EVERY TIME


























































































































